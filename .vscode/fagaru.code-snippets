{
  "Django Model for Fagaru": {
    "prefix": "fagaru-model",
    "body": [
      "from django.db import models",
      "from django.contrib.auth import get_user_model",
      "",
      "User = get_user_model()",
      "",
      "class ${1:ModelName}(models.Model):",
      "    \"\"\"",
      "    ${2:Description du modèle pour Fagaru.}",
      "    \"\"\"",
      "    ${3:field_name} = models.${4:FieldType}(${5:options})",
      "    ",
      "    def __str__(self):",
      "        return f\"${6:Représentation textuelle}\"",
      "",
      "    class Meta:",
      "        verbose_name = \"${7:Modèle}\"",
      "        verbose_name_plural = \"${8:Modèles}\""
    ],
    "description": "Crée un modèle Django pour le projet Fagaru avec structure standard"
  },

  "Django REST API ViewSet": {
    "prefix": "fagaru-viewset",
    "body": [
      "from rest_framework import viewsets, status",
      "from rest_framework.decorators import action",
      "from rest_framework.response import Response",
      "from django.shortcuts import get_object_or_404",
      "from .models import ${1:ModelName}",
      "from .serializers import ${1:ModelName}Serializer",
      "",
      "class ${1:ModelName}ViewSet(viewsets.ModelViewSet):",
      "    \"\"\"",
      "    ViewSet pour la gestion des ${2:modèles}.",
      "    \"\"\"",
      "    queryset = ${1:ModelName}.objects.all()",
      "    serializer_class = ${1:ModelName}Serializer",
      "",
      "    def get_queryset(self):",
      "        \"\"\"",
      "        Filtre les données selon le rôle de l'utilisateur.",
      "        \"\"\"",
      "        queryset = super().get_queryset()",
      "        user = self.request.user",
      "",
      "        # Logique de filtrage selon les rôles",
      "        if user.role == 'CITOYEN':",
      "            return queryset.filter(zone=user.zone)",
      "        elif user.role in ['ASC', 'ICP']:",
      "            return queryset.filter(zone__in=user.managed_zones.all())",
      "",
      "        return queryset",
      "",
      "    @action(detail=True, methods=['post'])",
      "    def ${3:action_name}(self, request, pk=None):",
      "        \"\"\"",
      "        Action personnalisée pour ${3:action_name}.",
      "        \"\"\"",
      "        instance = self.get_object()",
      "        # Logique métier",
      "        return Response({'message': '${3:action_name} effectué'}, status=status.HTTP_200_OK)"
    ],
    "description": "Crée un ViewSet DRF avec filtrage par rôle pour Fagaru"
  },

  "React Component for Fagaru": {
    "prefix": "fagaru-component",
    "body": [
      "import React, { useState, useEffect } from 'react';",
      "import { useAuth } from '../contexts/AuthContext';",
      "import { useFetch } from '../hooks/useFetch';",
      "",
      "/**",
      " * Composant ${1:ComponentName} pour Fagaru",
      " * ${2:Description du composant}",
      " */",
      "const ${1:ComponentName} = ({ ${3:props} }) => {",
      "  const { user } = useAuth();",
      "  const [${4:state}, set${4/(.*)/${4:/capitalize}/}] = useState(${5:initialState});",
      "",
      "  // Récupération des données",
      "  const { data, loading, error } = useFetch('${6:apiEndpoint}');",
      "",
      "  // Gestionnaire d'événements",
      "  const handle${7:Action} = async () => {",
      "    try {",
      "      // Logique métier",
      "      console.log('${7:Action} effectué');",
      "    } catch (error) {",
      "      console.error('Erreur:', error);",
      "    }",
      "  };",
      "",
      "  if (loading) return <div>Chargement...</div>;",
      "  if (error) return <div>Erreur: {error.message}</div>;",
      "",
      "  return (",
      "    <div className=\"${8:container-classes}\">",
      "      <h2 className=\"${9:title-classes}\">${1:ComponentName}</h2>",
      "      ",
      "      {/* Contenu du composant */}",
      "      <div className=\"${10:content-classes}\">",
      "        {data && data.map(item => (",
      "          <div key={item.id} className=\"${11:item-classes}\">",
      "            {item.${12:displayField}}",
      "          </div>",
      "        ))}",
      "      </div>",
      "    </div>",
      "  );",
      "};",
      "",
      "export default ${1:ComponentName};"
    ],
    "description": "Crée un composant React avec structure standard pour Fagaru"
  },

  "React Hook for Fagaru": {
    "prefix": "fagaru-hook",
    "body": [
      "import { useState, useEffect, useCallback } from 'react';",
      "import { useAuth } from '../contexts/AuthContext';",
      "",
      "/**",
      " * Hook personnalisé pour ${1:HookPurpose}",
      " * ${2:Description du hook}",
      " */",
      "export const use${1:HookName} = (${3:parameters}) => {",
      "  const { user } = useAuth();",
      "  const [${4:state}, set${4/(.*)/${4:/capitalize}/}] = useState(${5:initialState});",
      "  const [loading, setLoading] = useState(false);",
      "  const [error, setError] = useState(null);",
      "",
      "  // Fonction principale",
      "  const ${6:mainFunction} = useCallback(async (${7:params}) => {",
      "    setLoading(true);",
      "    setError(null);",
      "",
      "    try {",
      "      // Logique métier",
      "      const result = await ${8:apiCall};",
      "      set${4/(.*)/${4:/capitalize}/}(result);",
      "      return result;",
      "    } catch (err) {",
      "      setError(err.message);",
      "      throw err;",
      "    } finally {",
      "      setLoading(false);",
      "    }",
      "  }, [${9:dependencies}]);",
      "",
      "  // Effet pour initialisation",
      "  useEffect(() => {",
      "    if (${10:condition}) {",
      "      ${6:mainFunction}(${11:initialParams});",
      "    }",
      "  }, [${12:effectDeps}]);",
      "",
      "  return {",
      "    ${4:state},",
      "    loading,",
      "    error,",
      "    ${6:mainFunction},",
      "  };",
      "};"
    ],
    "description": "Crée un hook personnalisé avec structure standard pour Fagaru"
  },

  "API Service for Fagaru": {
    "prefix": "fagaru-service",
    "body": [
      "import api from './api';",
      "",
      "/**",
      " * Services API pour ${1:ServiceName}",
      " */",
      "export const ${2:serviceName}Service = {",
      "  ",
      "  /**",
      "   * Récupère la liste des ${3:items}",
      "   */",
      "  async get${3/(.*)/${3:/capitalize}/}List(filters = {}) {",
      "    try {",
      "      const response = await api.get('/${4:endpoint}/', { params: filters });",
      "      return response.data;",
      "    } catch (error) {",
      "      console.error('Erreur lors de la récupération des ${3:items}:', error);",
      "      throw error;",
      "    }",
      "  },",
      "",
      "  /**",
      "   * Récupère un ${3:item} par ID",
      "   */",
      "  async get${3/(.*)/${3:/capitalize}/}ById(id) {",
      "    try {",
      "      const response = await api.get('/${4:endpoint}/${id}/');",
      "      return response.data;",
      "    } catch (error) {",
      "      console.error('Erreur lors de la récupération du ${3:item}:', error);",
      "      throw error;",
      "    }",
      "  },",
      "",
      "  /**",
      "   * Crée un nouveau ${3:item}",
      "   */",
      "  async create${3/(.*)/${3:/capitalize}/}(data) {",
      "    try {",
      "      const response = await api.post('/${4:endpoint}/', data);",
      "      return response.data;",
      "    } catch (error) {",
      "      console.error('Erreur lors de la création du ${3:item}:', error);",
      "      throw error;",
      "    }",
      "  },",
      "",
      "  /**",
      "   * Met à jour un ${3:item}",
      "   */",
      "  async update${3/(.*)/${3:/capitalize}/}(id, data) {",
      "    try {",
      "      const response = await api.patch('/${4:endpoint}/${id}/', data);",
      "      return response.data;",
      "    } catch (error) {",
      "      console.error('Erreur lors de la mise à jour du ${3:item}:', error);",
      "      throw error;",
      "    }",
      "  },",
      "",
      "  /**",
      "   * Supprime un ${3:item}",
      "   */",
      "  async delete${3/(.*)/${3:/capitalize}/}(id) {",
      "    try {",
      "      await api.delete('/${4:endpoint}/${id}/');",
      "      return true;",
      "    } catch (error) {",
      "      console.error('Erreur lors de la suppression du ${3:item}:', error);",
      "      throw error;",
      "    }",
      "  },",
      "",
      "  /**",
      "   * Action personnalisée: ${5:customAction}",
      "   */",
      "  async ${6:customAction}(id, data = {}) {",
      "    try {",
      "      const response = await api.post('/${4:endpoint}/${id}/${6:customAction}/', data);",
      "      return response.data;",
      "    } catch (error) {",
      "      console.error('Erreur lors de ${6:customAction}:', error);",
      "      throw error;",
      "    }",
      "  },",
      "};",
      "",
      "export default ${2:serviceName}Service;"
    ],
    "description": "Crée un service API avec méthodes CRUD pour Fagaru"
  },

  "Alert Validation Logic": {
    "prefix": "fagaru-alert-validation",
    "body": [
      "/**",
      " * Logique de validation des alertes pour Fagaru",
      " * ${1:Description de la logique}",
      " */",
      "export const validateAlert = async (alertId, user) => {",
      "  // Vérification des permissions",
      "  if (!canValidateAlert(alertId, user)) {",
      "    throw new Error('Permission refusée pour valider cette alerte');",
      "  }",
      "",
      "  try {",
      "    // Récupération de l'alerte",
      "    const alert = await getAlertById(alertId);",
      "",
      "    // Vérification de l'état actuel",
      "    if (alert.status !== 'PENDING') {",
      "      throw new Error('L\\'alerte n\\'est pas en attente de validation');",
      "    }",
      "",
      "    // Logique de validation selon le rôle",
      "    const nextStatus = getNextValidationStatus(alert.status, user.role);",
      "",
      "    // Mise à jour de l'alerte",
      "    const updatedAlert = await updateAlert(alertId, {",
      "      status: nextStatus,",
      "      validated_by: user.id,",
      "      validation_date: new Date().toISOString(),",
      "    });",
      "",
      "    // Vérification d'escalade automatique",
      "    if (shouldEscalateAlert(updatedAlert)) {",
      "      await escalateAlert(alertId, 'Seuil dépassé');",
      "    }",
      "",
      "    return updatedAlert;",
      "  } catch (error) {",
      "    console.error('Erreur lors de la validation:', error);",
      "    throw error;",
      "  }",
      "};",
      "",
      "/**",
      " * Vérifie si un utilisateur peut valider une alerte",
      " */",
      "export const canValidateAlert = (alert, user) => {",
      "  const roleHierarchy = {",
      "    'CITOYEN': 1,",
      "    'ASC': 2,",
      "    'ICP': 3,",
      "    'MEDECIN_CHEF_CENTRE': 4,",
      "    'MEDECIN_CHEF_DISTRICT': 5,",
      "    'ADMIN': 6,",
      "  };",
      "",
      "  const userLevel = roleHierarchy[user.role] || 0;",
      "  const requiredLevel = getRequiredValidationLevel(alert.status);",
      "",
      "  return userLevel >= requiredLevel;",
      "};",
      "",
      "/**",
      " * Détermine le niveau requis pour valider selon le statut",
      " */",
      "const getRequiredValidationLevel = (status) => {",
      "  const levels = {",
      "    'PENDING': 2, // ASC minimum",
      "    'VALIDATED_ASC': 3, // ICP minimum",
      "    'VALIDATED_ICP': 4, // Médecin minimum",
      "    'ESCALATED': 5, // Niveau supérieur",
      "  };",
      "  return levels[status] || 6; // Admin par défaut",
      "};",
      "",
      "/**",
      " * Détermine le prochain statut après validation",
      " */",
      "const getNextValidationStatus = (currentStatus, userRole) => {",
      "  const transitions = {",
      "    'PENDING': userRole === 'ASC' ? 'VALIDATED_ASC' : 'PENDING',",
      "    'VALIDATED_ASC': userRole === 'ICP' ? 'VALIDATED_ICP' : 'VALIDATED_ASC',",
      "    'VALIDATED_ICP': 'VALIDATED',",
      "  };",
      "  return transitions[currentStatus] || currentStatus;",
      "};"
    ],
    "description": "Logique de validation des alertes avec hiérarchie des rôles"
  }
}
